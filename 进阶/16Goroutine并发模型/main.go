package main

func main() {
	/*

		Go语言内置了goroutine机制，使用goroutine可以快速地开发并发程序，更好的利用多核处理资源。
		一、线程模型
		操作系统层面，一定是以线程的形态存在。
		而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间。
		内核空间主要操作访问CPU资源、I/O资源、内存资源等硬件资源，位上层应用程序提供最基本的基础资源，
		用户空间就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。

		现在的计算机语言，可以侠义的认为是一种“软件”，他们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。

		Go并发编程模型在底层是由操作系统所提供的线程库支撑的，因此还是得从线程模型说起。
		线程可以是为进程中的控制流。
		一个进程至少会包含一个线程，因为其中至少会有一个控制流持续运行。因而，一个进程的第一个线程会随着这个进程的启动而创建，这个线程称为该进程的主线程。
		当然一个进程也可以包含多个线程。
		这些线程都是由当前进程中已存在的线程创建出来的，创建的方法就是调用系统调用，更确切地说是调用pthread create函数。
		拥有多个线程的进程可以并发执行多个任务，并且即使某个或某些任务被阻塞，也不会影响其他任务正常执行，这可以大大改善程序的相应时间和吞吐量。
		另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越其所属进程的生命周期。

		线程的实现模型主要有3个，分别是：用户级线程模型，内核级线程模型和两级线程模型。
		他们之间最大的差异就是在于线程于内核调度实体（Kernel Scheduling Entity,简称KSE）之间的对应关系上。
		顾名思义，内核调度实体就是可以被内核的调度器调度的对象。
		在很多文献和书中，它也称为内核级线程，是操作系统内核的最小调度单元。

		1.1内核级线程模型
		用户线程于KSE是1：1关系。大部分编程语言的线程库（如linux的pthread，Java的Java.lang.Thread, C++11的std::thread等等）都是对操作系统的线程（内核级线程）的一层封装，
		创建出来的每个线程与一个不同的KSE静态关联，因此其调度完全由OS调度器来做。
		这种方式实现简单，直接借助OS提供的线程能力，并且不同用户线程之间一般也不会相互影响。但其创建，销毁以及多个线程之间的上下文切换等操作都是直接由OS层面亲自来做，在需要使用大量线程的场景下对OS的性能影响会很大。

		每个线程由内核调度器独立的调度，所以如果一个线程阻塞则不影响其他的线程。
		优点：在多喝处理器的硬件的支持下，内核空间线程模型支持了真正的并行，当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。
		缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。

		1.2 用户级线程模型
		用户级线程与KSE是多对1关系（M:1），这种线程的创建，销毁以及多个线程之间的协调等操作都是由用户自己实现的线程库来负责，对OS内核透明，一个进程中所有创建的线程都与同一个KSE在运行时动态关联。
		现在有许多语言实现的协程基本上都属于这种方式。这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的数量与上下文切换所花费的代价也会小得多。
		但该模型有个致命的缺点，如果我们在某个用户线程上调用阻塞式系统调用（如用阻塞方式read网络IO），那么一旦KSE因阻塞被内核调度出CPU的话，剩下的所有对应的用户线程全都会变为阻塞状态（整个进程挂起）。

		所以这些语言的协程库会把自己一些阻塞的操作重新封装位完全的非阻塞形式，然后再以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。

		优点：这种模型的好处是线程上下文切换都发生在用户空间，避免了模型切换（mode switch），从而对于性能由积极影响。
		缺点：所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，在多处理器环境下这是不能够被接受的，本质上，用户 线程只解决了并发问题，但是没有解决并行问题。
		如果线程因为I/O操作陷入了内核态，内核态线程阻塞等待I/O数据，则所有的线程都会被阻塞，用户空间也可以使用非阻塞而I/O，但是不能避免性能及复杂度问题。

		1.3 两级线程模型
		用户线程与KSE是多对多关系（M:N），这种实现综合了前两种模型的优点，为一个进程种创建多个KSE，并且线程可以与不同的KSE在运行时进行动态关联，当某个KSE由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其有关联的其余用户线程可以重新与其他KSE建立关联关系。
		当然这种动态关联机制的实现很复杂，也需要用户自己去实现，这算是它的一个缺点吧。
		Go语言种的并发就是使用的这种实现方式，Go为了实现该模型自己实现了一个运行时调度器来负责Go种的“线程”与KSE的动态关联。
		此模型有时也被称为 混合型线程模型，即用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度。

		二、GO并发调度：G-P-M模型
		在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。
		goroutine机制实现了M:N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。

		2.1 调度器是如何工作的
		有个上面的认识，我们可以开始真正的介绍Go的并发机制了，先用一段代码展示一下在Go语言中新建一个"线程"（go语言中称为Goroutine）的样子
		//用go 关键字加上一个函数（这里用了匿名函数）
		//调用就做到了在一个新的“线程”并发执行任务
		go func(){
			// do something in one new goroutine
		}()

		理解goroutine机制的原理，关键是理解Go语言scheduler的实现。
		Go语言中支撑整个scheduler实现的主要有4个重要结构，分别是M、G、P、Sched，前三个定义在runtime.h中，Sched定义在proc.c中。
			1. Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。
			2. M结构是Machine，系统线程，它由操作系统管理的，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
			3. P结构是Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一个共routine队列，即runqueue。Processor是让我们从M：1调度到M:N调度的重要部分。
			4. G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。

		在单核处理器的场景下，所有goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor,任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueur中。
		多核处理器的场景下为了运行goroutine，每个M系统线程会持有一个 Processor.
		（图10：43）
		在正常情况下，scheduler会按照上面的流程进行调度，但是线程会发生阻塞等情况，看一下goroutine对线程阻塞等的处理。

		2.2 线程阻塞
		当正在运行的goroutine阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1），当前的M线程放弃了它的Processor，P转到新的线程中去运行。
		（图11：23）

		2.3 runqueue执行完成
		当其中一个Processor的runqueue为空，没有goroutine可以调度。他会从另外一个上下文偷取一般的goroutine。
		（图12：00）


	*/
}
